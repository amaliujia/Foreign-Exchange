1 INTRODUCTION
Gene duplication is known to have played a major role in the evolution of almost all life on Earth. For example, analyses of genomic data from numerous plants such as grasses (Guyot and Keller, ; Paterson et al., ; Schlueter et al., ; Wang et al., ; Yu et al., ), Arabidopsis or other Brassicaceae (Blanc et al., ; Bowers et al., ; Cannon et al., ; Schlueter et al., ; Schranz and Mitchell-Olds, ; Simillion et al., ; Vision et al., ; poplar (Sterck et al., ), cotton (Blanc and Wolfe, ; Rong et al., ) and Physcomitrella (Rensing et al., ), among others, have revealed evidence of ancient gene duplications. Complex evolutionary processes such as gene duplication and loss, recombination and horizontal gene transfer generate gene trees that differ from species trees. One approach to infer gene duplications is to reconcile the conflicting gene trees with respect to a trusted species tree (Bonizzoni et al., ; Chen et al., ; Goodman et al., ; GÃ³recki and Tiuryn ; GuigÃ³ et al., ; Mirkin et al., ; Page, ; Zhang ). Existing techniques that reconcile gene trees to species trees can identify gene duplications but cannot, in general, accurately locate them on the species tree. Other approaches make use of sequence similarity to reconstruct the underlying evolutionary history of genes (see, for example, Wapinski et al., ,). Probabilistic models for gene/species tree reconciliation as well as gene sequence evolution have also been developed (Arvestad et al., , ).

There is evidence that many gene duplications are part of larger multiple gene duplication episodes, during which a large portion of an organism's genome is duplicated. In fact, it is known that the entire genomes of numerous species (many eukaryotes for example) have been entirely duplicated one or more times. However, the rapid gene loss and gene rearrangements that follow a multiple gene duplication episode can make them difficult or even impossible to detect; and there is often no clear consensus on the number of ancient multiple gene duplication episodes or their precise location in evolutionary history.

Deciphering the location of gene duplications and multiple gene duplication episodes on the Tree of Life is a fundamental problem in understanding the way gene families and genomes evolve. The multiple gene duplication problem provides a framework for (i) mapping gene duplication events onto a given species tree and (ii) inferring and locating multiple gene duplication episodes. Informally, the multiple gene duplication problem is to assign duplication events to nodes in a species trees in such a way that the total number of multiple gene duplication episodes (or simply episodes in short) is minimized. This allows for a â€˜parsimoniousâ€™ reconciliation of the gene trees with respect to a trusted species tree, which helps to locate gene duplications, as well as to detect multiple gene duplication episodes, more accurately.

GuigÃ³ et al. () were the first to address a comprehensive phylogenetic problem that maps duplication events from a collection of rooted, binary gene trees onto a larger rooted binary species tree. They presented a heuristic that could be used to trace back the identified gene duplications to a few multiple gene duplication episodes. Later on, this heuristic approach was refined and restated in more formal terms, and used to study multiple gene duplication episodes in vertebrates by Page and Cotton (). Essentially, this heuristic approach sought to solve the multiple gene duplication problem of GuigÃ³ et al. by solving instead a similar problem which we refer to as the â€˜episode clusteringâ€™ problem. An alternative version of the multiple gene duplication problem was introduced by Fellows et al. () which they proved to be intrinsically difficult. Hence, we direct our focus to the work of GuigÃ³ et al. and Page and Cotton. The episode clustering problem determines duplication events using the Gene Duplication (GD) model from Goodman et al. (). Each duplication can be placed on any species on a path between the two (not necessarily distinct) most recent species that could have contained the duplication and its parent, respectively. In case the parent does not exist, the path runs between the most recent species for the duplication and the root of the species tree. An example is depicted in . The duplications in gene tree G are represented by the three bold vertices. Associated with each bold vertex is its path represented by an interval. For example, the interval [5,3] represents the path ã€ˆ5,4,3ã€‰ in the species trees S. Let g denote the node corresponding to the interval [5,3]. Species 5 is the most recent species that could have contained g and the parent of species 3, i.e. 2, is the most recent species that could have contained the parent of g. The Episode Clustering (EC) problem is, given a collection of gene trees and a species tree, find a minimum number of locations in the species tree where all duplications in the gene trees can be placed. For example, all three duplications in  can be placed on species nodes 2 and 3
A gene tree G and a comparable species tree S is depicted. The bold vertices in G are duplications and their intervals represent their allowed locations in the species tree S.



The EC problem itself has a long and interesting history. GuigÃ³ et al. () presented a heuristic approach to solve this problem. This heuristic was somewhat imprecise, and there were hints, but no formal algorithm, on how to deal with certain optimization steps. Page and Cotton () observed that the EC problem can be efficiently and cleanly reduced to the Set Cover problem. They approach the EC problem using a heuristic for the intrinsically difficult set-cover problem. Recently, Burleigh et al. () gave an efficient and exact solution for the EC problem. However, the EC problem itself suffers from a major limitation: it minimizes the number of locations in the species tree at which gene duplications occur, but it need not minimize the total number of episodes of multiple gene duplication. In fact, it is easy to find examples where minimizing the number of locations, does not minimize the number of episodes. Indeed, the desired goal in the papers of both GuigÃ³ et al. () and Page and Cotton () is to minimize the number of episodes, and the EC problem was used only as a heuristic approach for this problem. We refer to this problem of minimizing the number of episodes as the Minimum Episodes (ME) problem. In essence, the ME problem is the multiple gene duplication problem as defined by GuigÃ³ et al. ().

Thus, all previous attempts at solving the ME problem have made use of heuristics approaches based on the EC problem. In this article we finally solve a longstanding open problem by providing the first exact and efficient solution to the ME problem (see ). Our algorithm is surprisingly simple and extremely efficient. We have also implemented our algorithm and demonstrated the improvement it offers over the best heuristic approaches experimentally by applying it to several simulated as well as empirical datasets (see ).

2 BASIC DEFINITIONS, NOTATION AND PRELIMINARIES
In this section we first introduce basic definitions and notation that we shall use and then define the preliminaries required for this work.

2.1 Basic definitions and notation
A tree T is a connected graph with no cycles, consisting of a node set V(T) and an edge set E(T). T is rooted if it has exactly one distinguished node called the root which we denote by â„›â„´(T). Let T be a rooted tree. We define â‰¤T to be the partial order on V(T) where xâ‰¤T y if y is a node on the path between â„›â„´(T) and x. The set of minima under â‰¤T is denoted by â„’â„¯(T) and its elements are called leaves. If {x,y}âˆˆE(T) and xâ‰¤T y then we call y the parent of x denoted by ğ’«ğ’¶T(x) and we call x a child of y. The set of all children of y is denoted by ğ’ğ’½T(y). If two nodes in T have the same parent, they are called siblings. The least common ancestor of a non-empty subset LâŠ†V(T), denoted as lca(L), is the unique smallest upper bound of L under â‰¤T. A subtree of T rooted at node yâˆˆV(T), denoted by Ty, is the tree induced by {xâˆˆV(T) :xâ‰¤y}. T is (fully) binary if every node has either zero or two children. Throughout this article, the term tree refers to a rooted fully binary tree.

Given aâ‰¤T b we define the interval [a,b]={xâˆˆV(T)âˆ£aâ‰¤T xâ‰¤T b}. The height of T, denoted by h(T) is the number of nodes on a maximal length path from â„›â„´(T) to a leaf node of T. Thus, a rooted binary tree with three leaves has height three.

2.2 The ME problem
In this section we formally define the ME problem. The ME problem seeks to assign duplication events to nodes in a species tree, where each duplication event is associated with an interval in the species tree describing the locations where that duplication can be placed. The definition of duplication is based on the (GD) model introduced by Goodman et al. (). GuigÃ³ et al. () extended this model and defined the associated intervals for each gene duplication. Here we only provide definitions necessary to state the ME problem.

The GD model is based on a gene and species tree from which gene duplications can be derived. A species tree is a tree that depicts the evolutionary relationships of a set of species. Given a gene family for a set of species, a gene tree is a tree that depicts the evolutionary relationships among the sequences encoding only that gene family in the given species. Thus the vertices in a gene tree represent genes. In order to compare a gene tree G with a species tree S a mapping from each gene gâˆˆV(G) to the most recent species in S that could have contained g is required.

DEFINITION 2.1
[LCA Mapping] A leaf-mapping â„’G,Sâ€‰:â€‰â„’â„¯(G)â†’â„’â„¯(S) specifies, for each gene g, the species from which it was sampled. The extension â„³G,Sâ€‰:â€‰V(G)â†’V(S) of â„’G,S is the LCA mapping defined by â„³G,S(g)=lca(â„’G,S(â„’â„¯(Gg)).

DEFINITION 2.2
[Comparability] The trees G and S are comparable if there exists a leaf-mapping â„’G,S. A set of gene trees ğ’¢ and S are comparable if each gene tree in ğ’¢ is comparable with S.

Throughout the remainder of this article, ğ’¢ denotes a collection of input gene trees, S a comparable species tree, and G denotes an arbitrary gene tree in ğ’¢.

DEFINITION 2.3
[Duplication] A node vâˆˆV(G) is a (gene) duplication if â„³G,S(v)=â„³G,S(u) for some uâˆˆğ’ğ’½(v) and we define ğ’Ÿğ“Šğ“…(G,S)={gâˆˆV(G) âˆ£g is a duplication }.

DEFINITION 2.4
[Interval I(g)] For every gâˆˆğ’Ÿğ“Šğ“…(G,S), the interval I(g) is defined to be:
[â„³G,S(g),â„›â„´(S)], if g=â„›â„´(G),

[â„³G,S(g),â„³G,S(g)], if â„³G,S(g)=â„³G,S(ğ’«ğ’¶(g)) and

[â„³G,S(g),â„³G,S(ğ’«ğ’¶(g))]âˆ’{â„³G,S(ğ’«ğ’¶(g))}, otherwise.




DEFINITION 2.5
[Valid Mapping] A mapping â„±G,S :V(G)â†’V(S) is called valid if for each gâˆˆG,



Note: (i) â„± is used to denote the mapping âˆªGâˆˆğ’¢â„±G,S, and we say â„± is valid if â„±G,S is valid for each Gâˆˆğ’¢, (ii) given a mapping â„±, and a node sâˆˆV(S), we write â„±âˆ’1(s) to denote the set {g: â„±(g)=s} and (iii) in the remainder of this article, we denote by â„±â„³ the valid mapping âˆªGâˆˆğ’¢â„³G,S.

DEFINITION 2.6
[H(â„±,s)] Given ğ’¢ and S, a valid mapping â„±, and a node sâˆˆV(S), we define H(â„±,s) to be the sub-graph of ğ’¢ induced by the node set â„±âˆ’1(s).

Note that H(â„±,s) must be a forest.

Throughout this article we abbreviate the term â€˜multiple gene duplication episodeâ€™ simply to â€˜episodeâ€™. Given any valid mapping â„±, the following definition defines (i) the number of episodes, Î”(â„±,s), at each node sâˆˆV(S) and (ii) the total number of episodes Î”(â„±). For the actual definition of an episode itself, we refer the reader to GuigÃ³ et al. ().

DEFINITION 2.7
[Î”(â„±,s) and Î”(â„±)] Given a valid mapping â„± and a node sâˆˆV(S), we denote by Î”(â„±,s) the number of episodes at s caused by the mapping â„±. Then, Î”(â„±,s)=max{h(T)â€‰:â€‰TâˆˆH(â„±,s)}, and, Î”(â„±)=âˆ‘sâˆˆV(S)Î”(â„±,s).

DEFINITION 2.8
[Î”opt] Î”optâ€‰=min{Î”(â„±) :â„± is any valid mapping}.

ğ’¢ and S form the input for the ME problem. The output is a valid mapping â„±opt :âˆªGâˆˆğ’¢V(G)â†’V(S), such that Î”(â„±opt) is minimized. More formally,

PROBLEM 1.
Instance: A collection of gene trees ğ’¢ and a comparable species tree S.

Find: A valid mapping â„±opt such that Î”(â„±opt)=Î”opt.

3 THE ME PROBLEM
It is not hard to see that the number of distinct valid mappings can be extremely large (exponential in the size of the input). It is therefore infeasible to solve the ME problem by considering all possible valid mappings and then picking the one that causes the fewest episodes. In this section we give a simple and extremely efficient algorithm to solve the ME problem. The main idea of the algorithm is to traverse the species tree S in post-order, and perform greedy optimization steps at each node. As we shall prove, this leads us to a globally optimal mapping.

In order to state the algorithm, we must first define a few terms.

DEFINITION 3.1
[Leading node] Let â„± be a valid mapping and let sâˆˆV(S). Then, we say a node gâˆˆâ„±âˆ’1(s) is a leading node if and only if g=â„›â„´(T) where T âˆˆH(â„±,s) and h(T)=Î”(â„±,s).

DEFINITION 3.2
[Free node] Given a valid mapping â„±, and a node sâˆˆV(S) such that sâ‰ â„›â„´(S), a node gâˆˆâ„±âˆ’1(s) is called free if and only if ğ’«ğ’¶(s)âˆˆI(g).

For convenience, we refer to each node sâˆˆV(S) for which â„±âˆ’1(s)â‰ âˆ…, as a relevant node. Also recall that â„±â„³ denotes the mapping âˆªGâˆˆğ’¢â„³G,S.

We begin by stating the intuitive idea behind our algorithm. Consider any valid mapping â„± :âˆªGâˆˆğ’¢V(G)â†’V(S). Given any node sâˆˆV(S), let â„±â€² be a new mapping constructed from â„± by moving the mapping of all the free nodes in â„±âˆ’1(s) to ğ’«ğ’¶(s). Clearly, â„±â€² must be a valid mapping. Now, if all the leading nodes in â„±âˆ’1(s) are free, then we can show that Î”(â„±â€²)â‰¤Î”(â„±). On the other hand, if not all the leading nodes in â„±âˆ’1(s) are free, then we must have Î”(â„±â€²)â‰¥Î”(â„±). This simple observation forms the basis of our greedy algorithm. If these greedy optimizations are carried out in a particular order, then it can be shown that the resulting mapping will be an optimal one.

We are now ready to state our algorithm. The algorithm starts with the LCA mapping from the gene trees to the species tree, and progressively modifies it so that when the algorithm terminates, we have an optimal valid mapping. First, a valid mapping â„± :âˆªGâˆˆğ’¢V(G)â†’V(S) is initialized such that â„±â€‰=â„±â„³. Next, we traverse S in post-order, and at each node, say s, we check if it is relevant and if all the leading nodes in â„±âˆ’1(s) are free. If they are, then we modify the mapping â„± by changing the mapping of all the leading nodes in â„±âˆ’1(s) to ğ’«ğ’¶(s). It can be shown that when the post-order traversal is finished, the mapping â„± must be a solution to the ME problem (see Theorem 3.1). This algorithm is described more formally in Algorithm 1.
	


We denote the final mapping output by Algorithm 1 by â„±opt. In the remainder of this section we first show that â„±opt is a valid mapping and Î”(â„±opt)=Î”opt, and then study the complexity of Algorithm 1.

LEMMA 3.1.
â„±opt is a valid mapping.

PROOF.
Algorithm 1 starts with the mapping â„±â€‰=â„±â„³ which is valid by definition. During each iteration of the loop, the mapping â„± may be modified according to Equation (1). However, Equation (1) only modifies the mapping of those nodes that are free, and hence produces a valid mapping. Therefore, each mapping produced by the algorithm, including the mapping â„±opt, is valid.â€ƒâ–ª

LEMMA 3.2.
Let â„±: âˆªGâˆˆğ’¢V(G)â†’V(S) be any valid mapping. Then we have the following:
If sâˆˆV(S) is a relevant node under mapping â„±â„³, then Î”(â„±â„³,s)âˆ’1â‰¤Î”(â„±,s)â‰¤Î”(â„±â„³,s).

If sâˆˆV(S) is not a relevant node under mapping â„±â„³, then 0â‰¤Î”(â„±,s)â‰¤1.



PROOF.
Part 1: Here s is a relevant node i.e. . Let A denote the set of nodes that are present in  but not in â„±âˆ’1(s) and B denote the set of nodes that are present in â„±âˆ’1(s) but not in . Observe that all the nodes in A must be leading nodes in . Relocating all the leading nodes in  reduces Î”(â„±â„³,s) by exactly 1. Therefore, relocating the nodes in A reduces Î”(â„±â„³,s) by at most 1. This proves that Î”(â„±â„³,s)âˆ’1â‰¤Î”(â„±,s).

Consider now the set B. Let a and b be two gene duplication nodes from some gene tree in ğ’¢ such that one is an ancestor of the other, and â„±â„³(a)â‰ â„±â„³(b). Then, Definition 2.4 implies that â„±(a)â‰ â„±(b). Therefore, none of the nodes in set B is an ancestor of another, and hence none of them is a leading node in â„±âˆ’1(s). This proves that Î”(â„±,s)â‰¤Î”(â„±â„³,s).

Part 2: In this case , and therefore B=â„±âˆ’1(s). Following the argument from the previous paragraph, we can conclude that none of the nodes in set B is an ancestor of another. This implies that Î”(â„±,s)â‰¤1.â€ƒâ–ª

The following three lemmas are required for the proof of Theorem 3.1.

LEMMA 3.3.
Let â„±: âˆªGâˆˆğ’¢V(G)â†’V(S) be a valid mapping and sâˆˆV(S) be a node such that Î”(â„±opt,s)&gt;Î”(â„±,s). Then, Î”(â„±opt,s)=1.

PROOF.
There are two possible cases: (i) s is not a relevant node under â„±â„³ or (ii) s is a relevant node under â„±â„³. We analyze these cases separately.

Case (i): In this case, by Part 2 of Lemma 3.2, we must have Î”(â„±,s)=0 and Î”(â„±opt,s)=1.

Case (ii): If Î”(â„±â„³,s)&lt;2, then by Part 1 of Lemma 3.2 the result follows immediately; therefore, let us assume that Î”(â„±â„³,s)â‰¥2. Part 1 of Lemma 3.2 implies that we must have Î”(â„±,s)=Î”(â„±â„³,s)âˆ’1 and Î”(â„±opt,s)=Î”(â„±â„³,s).

Let A denote the set of nodes that are present in  but not in â„±âˆ’1(s), and B denote the set of nodes that are present in  but not in . All the nodes in A must be leading nodes in , and since these nodes are not present in â„±âˆ’1(s), all the nodes in A must be free as well. Also, none of the nodes in B can be a leading node in  (see the proof of Part 1 of Lemma 3.2). Therefore, all of the leading nodes in  must be present in A, which implies that all the leading nodes in  are free. Thus, during the execution of Algorithm 1, the mapping for these nodes would have been changed. This is a contradiction, and hence we cannot have Î”(â„±â„³,s)â‰¥2.â€ƒâ–ª

LEMMA 3.4.
Let node a be such that â„±â„³(a)&lt;S â„±opt(a). If â„±: âˆªGâˆˆğ’¢V(G)â†’V(S) is a valid mapping such that â„±(a)â€‰=â€‰â„±â„³(a), then Î”(â„±opt, â„±â„³(a))&lt;Î”(â„±,â„±â„³(a)).

PROOF.
Since â„±(a)&lt;S â„±opt(a), a must be a leading node in . This implies that Î”(â„±,â„±â„³(a))â‰®Î”(â„±â„³, â„±â„³(a)). Moreover, since â„±opt(a)â‰ â„±â„³(a), we have Î”(â„±opt,â„±â„³(a))=Î”(â„±â„³,â„±â„³(a))âˆ’1 (see Algorithm 1). The lemma follows.â€ƒâ–ª

LEMMA 3.5.
Let node a be such that â„±â„³(a)&lt;S â„±opt(a). If Î“â€‰=â€‰{x : â„±â„³(a)&lt;S x&lt;S â„±opt(a)}, then â„±opt(x)=0 for all xâˆˆÎ“.

PROOF.
Consider any node xâˆˆÎ“. There must exist some valid mapping â„±, realized during the execution of Algorithm 1, for which â„±(a)=x. However, as the execution of Algorithm 1 progresses, the mapping of a changes. This implies that a must be a leading node in â„±âˆ’1(a). Observe that a could be a leading node in â„±âˆ’1(a) only if Î”(â„±,x)=1. Furthermore, for the mapping of a to be changed, all the nodes in â„±âˆ’1(a) must be free, and would therefore not map to node x when the algorithm terminates. Thus, â„±opt(x)=0.â€ƒâ–ª

THEOREM 3.1.
Algorithm 1 solves the ME problem.

PROOF.
In Lemma 3.1 we have already established that â„±opt is a valid mapping. Therefore, to establish the correctness of our algorithm, it is sufficient to show that Î”(â„±opt)=Î”opt. Let us assume, for the sake of contradiction, that there exists some valid mapping â„± for which Î”(â„±opt)&gt;Î”(â„±). This implies that there must be at least one node sâˆˆV(S) for which Î”(â„±opt,s)&gt;Î”(â„±,s). We may assume, without any loss of generality, that s has the following property: there does not exist any other node tâˆˆV(Ss) for which Î”(â„±opt,t)&gt;Î”(â„±,t).

By Lemma 3.3 we know that node s must be such that Î”(â„±opt,s)â€‰=â€‰1. This implies that Î”(â„±,s)â€‰=â€‰0, i.e. â„±âˆ’1(s)â€‰=â€‰âˆ…. We will now show that there exists at least one node t âˆˆV(Ss)âˆ–{s} for which Î”(â„±opt,t)&lt;Î”(â„±,t). This would imply that .

Let ; clearly Aâ‰ âˆ…. We now have two possible scenarios, exactly one of which must be true: (i) â„±(g)&gt;S s for each gâˆˆA or (ii) there exists some gâˆˆA for which â„±(g)&lt;S s. If case (i) were possible, it would imply that all nodes in A are leading and free, and therefore Algorithm 1 would have already moved their mappings to nodes that are proper ancestors of s. Hence, case (ii) is the only possible scenario.

So far we have shown that if there exists some valid mapping â„± for which Î”(â„±opt)&gt;Î”(â„±), then there must exist some node, say a, where aâˆˆA and â„±(a)&lt;S s. Clearly, â„±â„³(a)â‰¤S â„±(a)&lt;S s. This leads us to two possible cases, exactly one of which must be true: (i) â„±â„³(a)=â„±(a) or (ii) â„±â„³(a)&lt;S â„±(a). If case (i) were true, then by Lemma 3.4 we must have Î”(â„±,â„±(a))&gt;Î”(â„±opt,â„±(a)). If case (ii) were true, then Lemma 3.5 implies that Î”(â„±opt,â„±(a))=0, but Î”(â„±,â„±(a))â‰ 0. Thus, in either case, there exists some tâˆˆV(Ss)âˆ–{s}, for which Î”(â„±opt,t)&lt;Î”(â„±,t). And hence, 

Now, let  and . Suppose there exists a node x such that â„±opt(x)âˆˆV(S)âˆ–V(Ss), and â„±(x)âˆˆV(Ss). Then, there are two possibilities: (i) â„±(x)âˆˆV(Ss)âˆ–{s} or (ii) â„±(x)=s. In case (i), Lemma 3.5 implies that  must be empty, which is clearly a contradiction. Similarly, case (ii) leads to a clear contradiction as well since â„±âˆ’1(s)=âˆ…. Therefore, such a node x cannot exist. And hence QâŠ†P.

All together, this implies that in the subtree Ss, the mapping â„± induces at least as many episodes as the mapping â„±opt, even though . Let us now construct a new valid mapping â„±â€²: âˆªGâˆˆğ’¢V(G)â†’V(S) as follows:



In light of the observation made in the previous paragraph, we must have Î”(â„±â€²)â‰¤Î”(â„±). Moreover, â„±â€² has fewer nodes s for which Î”(â„±opt,s)&gt;Î”(â„±â€²,s). Therefore, we can now set â„± to be â„±â€² and a straightforward induction argument completes our proof.â€ƒâ–ª

We now study the complexity of Algorithm 1. In order to simplify our analysis we assume that all Gâˆˆğ’¢ have approximately the same size. The input for the ME problem is the set of gene trees ğ’¢, and species tree S. Let n=|â„’â„¯(S)|, k=|ğ’¢| and m=|â„’â„¯(G)| for some Gâˆˆğ’¢.

THEOREM 3.2.
The time complexity of Algorithm 1 is O(kmn).

PROOF.
Computing the LCA mapping for all the gene trees takes O(kmn) time (Zhang ). With-in this time, the inverse LCA mapping is also easily computed. All the intervals I(g) can be computed in O(km) time. Now, at each node, s, in the species tree, we must (i) find all the leading nodes in â„±âˆ’1(s), (ii) check if these leading nodes are free and (iii) update the mapping â„±. Let x=|â„±âˆ’1(s)|, then, each of the Steps (i), (ii) and (iii) above can be completed in O(x) time. Hence, since x=O(km) and there are O(n) nodes in the species tree, we obtain a total time complexity of O(kmn) for Algorithm 1.â€ƒâ–ª

4 EXPERIMENTAL RESULTS
We evaluated the efficacy and efficiency of our novel algorithm for the ME problem through comparative studies on simulated and empirical datasets. For this evaluation we implemented our algorithm in the program EXACTMGD. We compared our program against the program APPROXMGD of Burleigh et al. () that implements the currently best known approach to solve the ME problem.

Recall that the objective of the ME problem is to produce a mapping which defines the fewest number of episodes. The smaller the number of episodes, the more accurate the mapping. Therefore, for each dataset we compared the programs by measuring three values: (i) The number of episodes defined by the initial LCA mapping (i.e. the unoptimized value), (ii) the number of episodes defined by the mapping produced by APPROXMGD and (iii) the number of episodes defined by the mapping produced by EXACTMGD. All analyses were performed on a 3 Ghz Intel Pentium 4 CPU based PC with Windows XP operating system. A run of EXACTMGD on each of these datasets terminated in less than 1s!

4.1 Simulated datasets
Our simulated datasets consist of 50 randomly generated gene trees, all with the same set of taxa, along with a randomly generated species tree. We generated four such datasets, each with a different number of taxa (50, 100, 200 and 400) in the input trees. EXACTMGD shows a significant reduction in the number of episodes as compared to APPROXMGD for each of the four datasets ().
Performance of EXACTMGD on simulated datasets

Dataset	Unoptimized	ApproxMGD	ExactMGD	
50 taxa	30	28	25	
100 taxa	47	38	35	
200 taxa	64	54	49	
400 taxa	65	45	40	


4.2 Empirical datasets
For the empirical study we evaluated two datasets from the literature. The first dataset consists of 53 gene trees, each representing the evolutionary history of different gene families from a set of 16 eukaryotes. This set was assembled and evaluated for episodes by GuigÃ³ et al. (). Subsequently, this dataset was reused and its evaluation refined by Page and Cotton (). The second dataset, assembled and evaluated for episodes by Burleigh et al. (), consists of 85 gene trees from the Phytome comparative plant genome database and contains genes from 136 plant taxa.

For brevity we refrain from performing biological analyses of our results; and only demonstrate the exceptional level of improvement offered by our algorithm over the best current methods. The results depicted in  show that the mappings produced by our algorithm are significantly more optimal compared to the mappings produced by the best current approaches. This leads to more accurate inference of the location of gene and genome duplications on the Tree of Life.
Performance of EXACTMGD on empirical datasets

Dataset	Unoptimized	ApproxMGD	ExactMGD	
GuigÃ³ et al. ()	9	7	5	
Burleigh et al. ()	1180	1152	1042	



5 OUTLOOK AND CONCLUSION
In this article we have provided the first exact and efficient algorithm for a longstanding open problem. Traditionally, the multiple episodes problem has been used to infer the location of episodes of multiple gene duplication on a given species tree. Our new algorithm allows this to be done far more accurately. But another interesting and important fallout of our algorithm is that it may also allow us to infer the â€˜correctâ€™ species trees. Consider the problem of constructing a species tree from conflicting gene trees based on the gene duplication optimality criteria. The gene duplication problem is to find for a given set of gene trees a corresponding species tree with the minimum reconciliation cost (Fellows et al., ; Hallett and Lagergren, ; Ma et al., ; Stege, ). However, since these gene duplication events are usually a part of larger multiple gene duplication episodes, it might be more helpful if we can infer species trees directly based on the multiple gene duplication optimality criteria (see also Fellows et al. ). Our algorithm offers the first practical and effective means to do so. The idea is to use a local search based hill climbing heuristic to traverse through the search space of possible species tree. Our algorithm can be used to compute the number of episodes induced by each candidate species tree during the local search steps. The lower the number of episodes, the better the species tree.

In addition, it would be interesting to extend the multiple GD model of GuigÃ³ et al. () by relaxing the constraints on the possible locations of gene duplications on the species tree.

1Note that mathematically speaking such a leaf-mapping always exists. However, in the current context, we are only concerned with biologically relevant leaf-mappings.

2When ğ’¢ is viewed as a forest.

3Our randomly generated trees have a random (binary) topology and a random assignment of leaf labels.

ACKNOWLEDGEMENTS
The authors wish to thank the anonymous referees for their invaluable comments.

Funding: This work was supported in part by National Science Foundation AToL grant EF-0334832.

Conflict of Interest: none declared.

