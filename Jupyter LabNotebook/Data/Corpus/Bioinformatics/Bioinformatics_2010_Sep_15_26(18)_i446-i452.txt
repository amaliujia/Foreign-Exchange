1 INTRODUCTION
A striking feature of mammalian genomes is the prevalence of segmental duplications or low-copy repeats. Approximately 5% of the human genome consists of segmental duplications &gt; 1 kb in length with ‚â• 90% sequence identity between copies (Bailey and Eichler, ). Segmental duplications account for a significant fraction of the differences between humans and other primate genomes, and are enriched for genes that are differentially expressed between the species (Blekhman et al., ).

Segmental duplications remain an extreme challenge for evolutionary reconstruction, as they are the ‚Äòmost structurally complex and dynamic regions of the human genome‚Äô (Alkan et al., ). Human segmental duplications are frequently found within complicated mosaics of duplicated fragments (Bailey and Eichler, ). Jiang et al. () produced a comprehensive annotation of this mosaic organization; they derived an ‚Äòalphabet‚Äô of approximately 11 000 duplicated segments, or duplicons, and delimited 437 duplication blocks or ‚Äòstrings‚Äô of at least 10 (and typically dozens) different duplicons found contiguously on a chromosome. However, the relationships between these annotated duplication blocks are complex and straightforward analysis does not immediately reveal the evolutionary relationships between blocks.

Numerous authors have considered the problem of analyzing relationships between genome sequences that contain duplicated segments. This work falls into roughly two categories. The first focus is the problem of computing genome rearrangement distances, like reversal distance, in the presence of duplicated genes or synteny blocks (El-Mabrouk, ; Marron et al., ; Sankoff, , for example). However, such rearrangement distances do not model the creation of new duplicates and thus are not well-suited to describe the evolutionary history of segmental duplications in the genome. The second focus is to analyze regions with duplications under ‚Äòlocal‚Äô operations like tandem duplications (Chaudhuri et al., ; Lajoie et al., , for example). While tandem duplication is undoubtedly important in the generation of duplication blocks, there is strong evidence that an important characteristic of the history of segmental duplications is the frequent duplication and transposition of long segments over large physical distances; as many as 50‚Äì60% of segmental duplications were transposed interchromosomally (Bailey and Eichler, ). Several general models of rearrangement that allowed for both local operations and duplication‚Äìtransposition-like operations between different strings were studied by Ergun et al. (), but the generality of those models meant that the distances were NP-hard to compute and only approximation algorithms were given.

Here, we present a novel formulation of the problem of computing an evolutionary history for a set of segmental duplications that are organized in duplication blocks. We represent evolutionary relationships between a set of duplication blocks as a directed acyclic graph (DAG), and we formalize the evolutionary reconstruction problem as an optimization over the space of DAGs.

We present two different methods for scoring a DAG: one based on parsimony and one based on likelihood. The parsimony score for a DAG is a straightforward extension of ‚Äòduplication distance‚Äô, a measure introduced by some of us (Kahn and Raphael, , ) that describes the most parsimonious sequence of duplicate operations needed to construct a given target string. The likelihood score for a DAG is the product of the likelihood scores for each of the duplication blocks, where a duplication block's likelihood is derived by computing the weighted ensemble of all possible duplication scenarios that could have generated it. We describe how to compute the partition function of the ensemble efficiently using a dynamic program that generalizes the duplication distance (i.e. parsimony score) recurrence. Deriving a probabilistic model from a dynamic program this way is analogous to the approach of McCaskill () who applied dynamic programming to RNA folding to compute the partition function of all secondary structures and to assign probabilities to certain substructures..

Finally, we solve these evolutionary reconstruction problems on the set of duplication blocks identified by Jiang et al. () using a local search technique based on simulated annealing. We compare these reconstructions to the analysis of Jiang et al. (). Our evolutionary reconstruction recapitulates some of the properties of earlier analysis but also reveals additional and more subtle relationships between segmental duplications.

2 METHODS
Here, we present two methods for determining the optimality of an evolutionary relationship between a pair of duplication blocks‚Äîone based on a parsimony criterion and one based on a likelihood criterion. In  and , we describe the parsimony-based model of segmental duplication that is based on duplication distance, introduced in Kahn and Raphael (, ). Next, we present a novel probabilistic model of segmental duplication that we use to compute the likelihood score for an evolutionary relationship between a pair of duplication blocks.

2.1 A model of segmental duplication
As noted above, an important characteristic of segmental duplications that distinguishes them from other types of repeats is that they are frequently transposed across large genomic distances from their respective ancestral loci. In Kahn and Raphael (, ), we modeled the process in which a duplication block, a composite of many duplicons, is built by copying strings of duplicons from other duplication blocks. In particular, we define the basic ‚Äòcopy‚Äìpaste‚Äô operation as follows.

Definition 2.1.
A duplicate operation, Œ¥s,t,p(X), copies a substring Xs,t of a source string X and pastes it into a target string at position p. Specifically, if X = x1‚Ä¶xm and Z = z1‚Ä¶zn, then Z ‚óã Œ¥s,t,p(X) = z1‚Ä¶zp‚àí1xs‚Ä¶xtzp‚Ä¶zn.

Definition 2.2.
The duplication distance, d(X, Y), from a source string X to a target string Y is the minimum number of duplicate operations needed to construct Y by copying and pasting substrings of X into an initially empty target string.

A subsequence is distinguished from a substring because the characters of a subsequence need not be contiguous. Given a string X, a subsequence S of X can be expressed as an increasing list of indices of X. For example, for X = abcdefg, the subsequence S = (1, 3, 5) is the string ace.

Definition 2.3.
Two subsequences S = (s1, s2,‚Ä¶, sls) and T = (t1, t2,‚Ä¶, tlt) of a string X overlap if either (i) there exist indices i : 1 ‚â§ i &lt; ls and j : 1 ‚â§ j &lt; lt such that i = j, or (ii) there exist indices i, i‚Ä≤ : 1 ‚â§ i &lt; i‚Ä≤ &lt; ls and a j, j‚Ä≤ : 1 ‚â§ j &lt; j‚Ä≤ &lt; lt such that either i &lt; j &lt; i‚Ä≤ &lt; j‚Ä≤ or j &lt; i &lt; j‚Ä≤ &lt; i‚Ä≤.

Given a source/target pair X, Y, any sequence of duplicate operations of the form Œ¥s1,t1,p1(X),‚Ä¶, Œ¥sd,td,pd(X) that generates Y from X uniquely partitions the characters of Y into non-overlapping subsequences corresponding to characters that were copied conjointly from X.

Definition 2.4.
Given a source string X, a generator Œ®X = (Xi1,j1,‚Ä¶, Xik,jk) is a sequence of substrings of X.

Definition 2.5.
A generator Œ®X = (Xi1,j1,‚Ä¶, Xik,jk) is feasible for a target string Y, that we denote as Œ®X ‚ä£ Y, if:
The elements of Œ®X partition the characters of Y into mutually non-overlapping subsequences {S1,‚Ä¶, Sk}.

There exists a bijective mapping f : {Xi,j‚àà Œ®X} ‚Üí {S1,‚Ä¶, Sk} from substrings of X to subsequences in Y corresponding to how the elements of Œ®X partition Y.

The order of elements in Œ®X corresponds to the order of the leftmost characters of the subsequences f(Xi1,j1),‚Ä¶, f(Xik,jk) in Y.




See .
An example of a sequence of duplicate operations that constructs Y = deabdec from X = abcde. The corresponding feasible generator is: Œ®X = (X4,5, X1,3, X4,5) = ((de), (abc), (de)).



A sequence of k duplicate operations that constructs Y from X uniquely defines a feasible generator Œ®X with length k whose elements correspond, respectively, to substrings of X that are duplicated conjointly in a single operation.

2.2 Parsimony
In Kahn et al. (), we describe a polynomial-time algorithm to compute the duplication distance from X to Y. We use duplication distance to measure the similarity between a pair of duplication blocks by counting the number of operations needed to generate Y from X in a simplest or most-parsimonious scenario.

While the parsimony assumption is attractive from a theoretical perspective and can produce useful biological insight, it might be overly restrictive, particularly when there are many different optimal or nearly optimal solutions. Consider, for example, the strings X = ‚Äòa‚Äô, ‚Äòb‚Äô, ‚Äòc‚Äô, ‚Äòd‚Äô, ‚Äòe‚Äô, ‚Äòf‚Äô, and ‚Äòg‚Äô, hijkl, and Y = agdbhecifdajebkfclg. The duplication distance, d(X, Y), is 13 and there is a single feasible generator with this optimum length. However, there are 989 possible feasible generators for Y, 119 of which have length 14, just slightly suboptimal.

Because the space of all possible feasible generators is very large, a probabilistic model might give very low probability to an optimal parsimony solution. Thus, in the next section, we present a probabilistic model of segmental duplication that considers the weighted ensemble of all feasible generators for a source/target string pair.

2.3 The partition function
For a given source string X and positive integer k, we consider the space of all length-k generators Œ®X. We define a probability distribution on the collection of generators by defining Pr[Œ®X] ‚àù œâ(Œ®X) where œâ(Œ®X) is the ‚Äòscore‚Äô, or weight, assigned to a generator, and we compute the partition function ZX(k) of the weighted ensemble of all possible length‚àík generators Œ®X. Given a source string X and a target string Y, we define the event F to be the event of choosing a length-k generator that is feasible for Y from the space of length-k generators. We define a probabilistic model for segmental duplications that, given a target string Y, assigns a probability to F: Pr[F|Y, X, k]. For a fixed target string Y, the probability, Pr[F|Y, X, k], is the weighted ensemble of all possible length-k generators that are feasible for Y, normalized by the partition function ZX(k). In particular, we can express the probability as:

where |Œ®X| denotes the length of the generator. The likelihood of a target string Y then can be expressed as L(Y|F, X, k) = Pr(F|Y, X, k).

The score of a generator, œâ(Œ®X), can be defined according to various biological models. Although different functions œâ may require different algorithms for computing the value Pr[F|Y, X, k], we found that functions of the form œâ(Œ®X) = œÉ(|Œ®X|, l(Œ®X)) where l(Œ®X) = ‚àëXi,j‚ààŒ®X |Xi,j| denotes the sum of the lengths of the elements of Œ®X, admit particularly efficient algorithms for computing Equation (). We discuss the score function further in Supplementary Section 1.2.

Now, we give an algorithm to compute the partition function, ZX(k). Given a score function of the form œÉ(|Œ®X|, l(Œ®X)), each length-k generator whose elements have lengths that sum to l are scored the same, namely œÉ(k, l). Therefore, in order to compute ZX(k), we must calculate the total number of length-k generators whose lengths sum to l for all relevant values of l. Let ùíûX(k)(l) equal the number of distinct length-k generators for which the sum of the lengths of the elements equals l.

Lemma 2.6.
Let X = x1‚Ä¶x|X| be a source string and let k and l be positive integers. The function ùíûX(k)(l) satisfies the following recurrence.


For a source string X and integers k, l, if we are given ùíûX(k)(l), we can compute ZX(k) efficiently by summing ùíûX(k)(l) over all relevant lengths l, weighting each feasible generator appropriately according to the function œÉ(k, l).

Theorem 2.7.
Let X = x1‚Ä¶x|X| be a source string and k be a positive integer. The partition function ZX(k) satisfies the following.


Note that the elements of a length-k list of substrings of X can have lengths that sum to at least k and at most |X| ¬∑ k.

The recurrence in Lemma 2.6 can be computed in O(|X|k) time, so ZX(k) can be computed in O(|X|2k2) time according to Theorem 2.7. We omit a proof of correctness due to space considerations.

2.4 Restricted partition function
In this section, we present the final ingredient necessary to compute the probability Pr[F|Y, X, k], namely the sum in Equation () that we define as QX(k)(Y). We refer to the value QX(k)(Y) as the restricted partition function of feasible generators, and it is equal to the weighted ensemble of all length-k generators Œ®X that are feasible for Y. Hence QX(k)(Y) = ‚àëŒ®X‚ä£Y:|Œ®X|=kœâ(Œ®X) = ‚àëŒ®X‚ä£Y:|Œ®X|=kœÉ(k, |Y|).

In order to compute this value, we generalize the recurrence presented in Kahn et al. () for computing duplication distance from source string X to target string Y to count the number of length-k generators that are feasible for Y.

Lemma 2.8.
Given a source string X = x1‚Ä¶x|X| and a target string Y = y1,‚Ä¶, y|Y|, the number NX(k)(Y) of distinct length-k generators Œ®X that are feasible for Y satisfies the following recurrence.


Here, the term NX(k)(Y, i) represents the number of feasible generators Œ®X with length k given that the character y1 is generated by a substring of X starting at xi.

We compute the restricted partition function QX(k)(Y) efficiently by first counting the number of relevant feasible generators, namely NX(k)(Y), and scoring each generator appropriately by œÉ(k, |Y|).

Theorem 2.9.
Let X = x1‚Ä¶x|X|, Y = y1,‚Ä¶, y|Y| be a source/target string pair and let k be a positive integer. The restricted partition function QX(k)(Y) satisfies the following.


The recurrence given in Lemma 2.8 can be computed in time O(|Y|2k2Œº(Y)Œº(X)) where Œº(Y) (resp. Œº(X)) is the maximum multiplicity of any character that appears in Y (resp. X), so computing QX(k)(Y) takes the same time. We include a proof of correctness in Supplementary Section 1.1.

3 ALGORITHM
Here, we formalize the problem of computing a segmental duplication evolutionary history for a set of duplication blocks in the human genome with respect to either a parsimony or likelihood criterion.

3.1 Maximum parsimony and maximum likelihood evolutionary histories
The input to our problem is the set of duplication blocks found in the human genome, each represented as a signed string on the alphabet of duplicons. Our goal is to compute a putative duplication history that accounts for the construction of all of the duplication blocks. We assume that the ancestral genome is devoid of segmental duplications. A duplication history is a sequence of duplicate events that first builds up a set of seed duplication blocks by duplicating and aggregating duplicons from their ancestral loci and then successively constructs the remaining duplication blocks by duplicating substrings of previously constructed blocks.

We observed in Kahn and Raphael () strong evidence that many of the duplication blocks identified by Jiang et al. () had been constructed through the duplication and aggregation of substrings of duplicons from several other blocks. Therefore, a tree cannot aptly represent an evolutionary history; a more appropriate representation of the evolutionary relationships between duplication blocks is a DAG in which the vertices represent duplication blocks and an edge directed from a vertex X to a vertex Y indicates that substrings of X were duplicated in the construction of Y. A vertex with multiple incoming edges and, therefore, multiple parents, is constructed using substrings of all of the parent blocks. Specifically, given a DAG G = (ùíü, E), for Y ‚àà ùíü, we define PG(Y), the parent string of Y, by PG(Y) = X1 ‚äô X2 ‚äô‚Ä¶‚äôXp where Xi ‚àà {ùíü|(Xi, Y) ‚àà E} and ‚äô indicates the concatenation of two strings with a dummy character inserted in between.

We make two simplifying assumptions. First, we assume that only duplicate events occur and that there are no deletions, inversions, or other types of rearrangements within a duplication block. Second, we assume that a duplication block is not copied and used to make another duplication block until after it has been fully constructed, ensuring the evolutionary relationships cannot contain cycles. We acknowledge that our two simplifying assumptions restrict the evolutionary history reconstruction problem significantly, but admit an efficient and consistent method of scoring a solution. Similar assumptions were made, for example, by Price et al. () to derive the evolutionary tree for Alu repeat elements.

We can define the optimal DAG with respect to a parsimony criterion using duplication distance (Definition 2.2).

Definition 3.1.
Given a set of duplication blocks ùíü, the maximum parsimony evolutionary history is the DAG G = (ùíü, E) that minimizes f(G) = ‚àëY‚ààùíüd(PG(Y), Y).

We can also define the optimal DAG with respect to a likelihood criterion. In phylogenetic tree reconstruction, a max likelihood solution is a tree that maximizes the probability of generating the characters at the leaf nodes over all possible tree topologies, branch lengths, and assignments of ancestral states to the internal nodes. Typically, the evolutionary process is assumed to be a Markov process so that the probabilities along different branches are independent. We similarly define the maximum likelihood DAG using the probabilistic model derived in . We maximize the likelihood of the solution over all DAG topologies and‚Äîinstead of branch lengths‚Äîthe numbers of operations permitted to construct each node.

Definition 3.2.
Given a set of duplication blocks ùíü, the maximum likelihood evolutionary history is the DAG G = (ùíü, E) that maximizes the likelihood:

where ZPG(X)(k) and Q(k)PG(Y) are the partition function and restricted partition functions, respectively.

4 IMPLEMENTATION
We analyzed a set of 391 duplication blocks identified by Jiang et al. () that were represented as signed strings on an alphabet of ‚âà 11 000 duplicons. We computed the maximum parsimony evolutionary history (Definition 3.1) for the entire set of blocks (). The DAG exhibited multiple connected components. For comparison, we then computed the maximum likelihood evolutionary histories (Definition 3.2) for several of the subgraphs induced by connected components of the parsimony solution. We scored generators according to  (see Supplementary Section 1.2).
The maximum parsimony DAG for a set of 391 duplication blocks in the human genome. The nodes represent duplication blocks. Edges indicate evolutionary relations; an edge is directed from a node u to a node v if the most-parsimonious duplication scenario includes duplication events that copy substrings of u in the construction of v. Jiang et al. () partitioned the duplication blocks into a set of 24 clades (plus one ‚Äòs‚Äô group of duplication blocks found in subtelomeric regions) that we indicate here with 25 colors on nodes. The 3 sets of colored edges represent inheritance networks for 3 conserved subsequences of duplicons. These inheritance networks are almost entirely confined to a single clade each. The green edges represent the inheritance of the duplicon sequence [6968, 6967, 6965, 6963, 6962, 6960] in clade ‚ÄòM1‚Äô, the red edges represent the inheritance of [7039, 7036, 7037] in clade ‚ÄòM2‚Äô, and the blue edges represent the inheritance of [9448,9449] in clade ‚Äòchr16.‚Äô



We used a simulated annealing strategy to find a maximum parsimony DAG for the entire set of duplication blocks and to find maximum likelihood DAGs for several subgraphs (see Supplementary Section 1.3 for details). For each input, we ran our local search 300 times. We started the search an equal number of times at each of three different types of initial graphs: (i) the empty graph with no edges; (ii) the directed minimum spanning tree (MST); and (iii) a randomly chosen DAG (chosen independently for each trial). Finally, to focus the search on the most important block relationships, we considered only edges between blocks whose longest common subsequence (LCS) contained at least 20 duplicons.

4.1 Maximum parsimony reconstruction
The maximum parsimony DAG contains 391 nodes and 479 edges. There are nine connected components with at least four duplication blocks, and nearly 40% of the blocks appear in the largest connected component.  shows a moderately-sized connected component. The graph also contains a total of 105 singleton nodes for which we did not infer any evolutionary relations with other duplication blocks, 97 of which did not exhibit an LCS of length 20 with any other block.
A connected component of the maximum parsimony DAG. Nodes from clade ‚ÄòM1‚Äô are red and nodes from clade ‚Äòchr7_2‚Äô are green. Node labels correspond to duplication block IDs. The blue edges represents the inheritance network for non-core duplicon 6970.



The maximum parsimony DAG represents a scenario in which all 391 duplication blocks could have been constructed in a sequence of 17 431 total duplicate operations. As a baseline comparison, a minimum spanning tree, with respect to duplication distance, on the set of duplication blocks has a total parsimony score of 28 852 and by definition, contains 390 edges.

4.2 Clades and core duplicons
Jiang et al. () performed an initial analysis of the duplication blocks. They defined 24 clades, or groups of duplication blocks derived from a common ancestor block, by performing hierarchical clustering on a matrix representing the shared presence or absence of duplicons for every pair of blocks. For a given clade they defined a core duplicon as one that appears in at least 67% of the constituent duplication blocks. They posited that clades represent families of evolutionarily related duplication blocks and that core duplicons ‚Äòmay have driven the evolution of the duplication blocks‚Äô in a clade.

After construction, we colored the nodes of our DAG according to the clades described in Jiang et al. (). We found a strong correspondence between Jiang et al.'s clades and connected subgraphs in our DAG; five of the nine connected components with at least four blocks were comprised of duplication blocks belonging to a single clade and seven of the nine components were comprised of blocks belonging to no more than two clades. For example, see a and a. In larger components, nodes from a single clade frequently induce a connected subgraph. For example, see .
(a) Component comprised entirely of duplication blocks from clade ‚Äòchr16‚Äô in the maximum parsimony DAG. (b) Maximum likelihood DAG for subgraph induced on nodes in (a).


(a) Component comprised entirely of duplication blocks from clade ‚Äòchr10‚Äô in the maximum parsimony DAG. (b) Maximum likelihood DAG for subgraph induced on nodes in (a).



Our DAG also reveals which duplication blocks may have seeded many other blocks (i.e. those with high out-degree). For example, in , block 399 exhibits eight children and is an inflection point for the component. Moreover, the edge from block 399 to 405 links blocks from the the ‚ÄòM1‚Äô and ‚Äòchr7_2‚Äô clades. Even though the blocks 399 and 405 belong to different clades, 405 is very ‚Äòclose‚Äô to 399 in duplication distance: block 405 contains only 71 duplicons, but it shares a subsequence of 29 duplicons with block 399. This link suggests that the entirety of clade ‚Äòchr7_2‚Äô was descended from clade ‚ÄòM1‚Äô in an optimal duplication history.

Also implicit in the DAG is information about which duplicons are duplicated from one block to another in an optimal duplication history. We define the inheritance network for each duplicon as the subgraph induced on the edges on which that duplicon is passed from parent to child. Interestingly, a comparison of the inheritance networks for core and non-core duplicons revealed that many non-core duplicons exhibit larger inheritance networks within subgraphs induced by a clade than core duplicons. For example, non-core duplicon 6970 appeared on 36 of the 63 total edges in the subgraph induced by clade ‚ÄòM1‚Äô (shown in blue in ) and does not appear on any other edge in the graph. In contrast, the maximum size of the inheritance network of a core duplicon was only 17. We propose 6970 as a new core duplicon for this clade and suggest that others like it should also be categorized as core duplicons.

Moreover, we found inheritance networks for many conserved subsequences of duplicons that were nearly as prominent as those for individual core duplicons. For example, the subsequence [6968, 6967, 6925, 6963, 6962] of duplicons appears on 23 of the edges in the subgraph induced by ‚ÄòM1‚Äô clade nodes (shown as green edges in ). Similarly, the sequence [7039, 7036, 7037] exhibits a connected inheritance network of 7 edges within the subgraph induced on clade ‚ÄòM2‚Äô, and [9448, 9449] exhibits an inheritance network of seven edges within the subgraph induced on clade ‚Äòchr16‚Äô that includes an inheritance path of length 5 (). By delineating the inheritance networks of duplicon subsequences that are conserved across duplication blocks, we can learn about which duplicons were duplicated and transposed conjointly. This type of analysis was impossible using only the clade annotations of Jiang et al. ().

4.3 Maximum likelihood reconstruction
We computed the maximum likelihood DAGs (Definition 3.2) for the sets of duplication blocks appearing within moderately sized connected components of the maximum parsimony DAG in order to compare the two methods. We chose the components comprised of blocks from clades ‚Äòchr16‚Äô and ‚Äòchr10‚Äô, respectively (). The maximum likelihood subgraphs for these subproblems are shown in b and b.

The two DAGs for the ‚Äòchr16‚Äô component in  share some characteristics. For example, node 121 is a common ancestor of every other block and block 276 exhibits high out-degree in both solutions. Both solutions are similarly ‚Äògood‚Äô with respect to the parsimony objective: the solution in (a) exhibits an optimal parsimony score of 397, and the one in (b) exhibits a score of 401. However, the likelihood score for the parsimony solution in (a) was nearly zero. One difference that accounts for this discrepancy is the higher average in-degree for blocks in the parsimony solution (2.2) as compared to the likelihood solution (1.3). Also, the parsimony solution exhibits a path with ten edges, whereas the longest path in the likelihood solution has six.

Some of these differences are due to the fact that the parsimony criterion does not penalize edges that do not directly improve the score. For example, block 291 has two parents (276 and 25) in the parsimony DAG but only one parent (276) in the likelihood DAG. However, the duplication distance with source 276 ‚äô 25 and target 291 is the same as the duplication distance with source 276 and target 291. Therefore, the edge from 25 to 291 does not improve the parsimony score, underscoring that there are multiple optimal parsimony solutions. In contrast, the likelihood of a target block generally increases as the sum of the lengths of its parent blocks decreases, so the max likelihood DAG will not include edges that do not directly improve the score.

5 DISCUSSION
Our maximum parsimony and maximum likelihood reconstructions show some differences, both from each other and from the analysis of Jiang et al. (). In particular, we identify non-core duplicons and subsequences that are arguably as promiscuous within a clade as core duplicons.

There are several directions for future work. From a theoretical perspective, one can incorporate other types of operations into the probabilistic model, such as deletions and inversions which we have described in the parsimony setting (Kahn et al., ), as well as single nucleotide mutations. Also, our method could be used to sample over the space of DAGs using a Markov Chain Monte Carlo strategy. From the perspective of applications, a more comprehensive analysis of genes or other elements in the newly identified core duplicons and core subsequences from our reconstruction is warranted, as is a further refinement of the clade annotation by analyzing the clade-induced subgraphs of the DAGs.

Funding: Career Award at the Scientific Interface from the Burroughs Wellcome Fund (to B.J.R.).

Conflict of Interest: none declared.

Supplementary Material
Supplementary Data
1In (Kahn and Raphael, , ), we also considered duplicate reversals in which the copied substring is inverted before being inserted into the target. We note that all of our definitions and algorithms presented here can be similarly augmented but we omit the details.

2We note that the duplication distance between a pair of strings is not formally a distance as it is asymmetric.

3The value ùíûX(k)(l) is related to the well-known integer partition function p(n) and corresponding Young tableaux. If ùí´(l, k) is the set of partitions of the integer l into k parts, we can express ùíûX(k)(l) = ‚àëP‚ààùí´(l,k)‚àëp‚ààP(|X| ‚àí p +1) ¬∑ k!.

4Both the max parsimony and max likelihood versions of the problem can be shown to be NP-hard by a reduction from the problem of Learning Bayesian Networks.

